---
title: "Функция обратного вызова (callback) или итератор в Python"
timestamp: 2016-03-19T08:56:01
tags:
  - for
published: true
books:
  - python
author: szabgab
original: callback-or-iterator-in-python
translator: name2rnd
archive: true
---


Раньше мы видели, как [функции обратного вызова (колбеки) могут быть лучше простых функций](/function-or-callback-in-python),
но есть и другие варианты. Мы можем создать, вероятно, неограниченный итератор, который будет
обходить элементы нашей последовательности, делая код еще более понятным, чем даже решение с колбеками.


## Решение с колбеком

Просто для напоминания - вот наше решение с колбеком. У нас есть функция fibonacci, которая проходит элементы последовательности, 
и для каждого элемента вызывает переданную функцию `check_17`.

{% include file="examples/python/fibonacci_function_callback.py" %}

Тот факт, что мы должны иметь возможность передать функции `fibonacci`
сигнал, когда остановиться, делает наш код несколько сложнее, чем мы надеялись.
Мы должны возвращать массив, в котором первый элемент выполняет роль индикатора (True/False).

## Создание Fibonacci-итератора

Давайте сделаем все наоборот и позволим пользователю вернуть контроль над циклом. 
Мы создаем класс `Fibonacci`, который будет итерабельным вследствие добавления
метода `__iter__`, который просто возвращает объект,
и метода `next` (В Python 3, думаю, это будет `__next__`),
который возвращает следующий элемент.

Внутри объект содержит текущее состояние итерации. В нашем случае это значит,
что он должен содержать последние два элемента последовательности.

{% include file="examples/python/fibonacci_iterator.py" %}

Вызов `fib = Fibonacci()` создаст объект итератора, который мы можем использовать 
в конструкции `for in` для перебора элементов.
Поскольку это неограниченный итератор, то есть, он не имеет конца,
мы должны быть уверены, что есть какой-то код внутри цикла `for`,
который его как-то остановит.

Решение выглядит проще, чем вариант [с колбеками](/function-or-callback-in-python).
